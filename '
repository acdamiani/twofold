#include "transform.h"
#include <cmath>
#include <cstdint>
#include <cstdio>
#include <vector>
#include "window.h"

Transformer::Transformer(std::vector<double> buffer, double target_interval,
                         uint32_t sampling_rate) {
  buffer_ = buffer;
}

uint32_t get_best_n(double target_interval, uint32_t sampling_rate) {
  if (target_interval <= 0.0) {
    printf("ERROR: target_interval should be greater than 0");
    return 0;
  }

  // FFTW is fastest when working with numbers in the form 2^a, 3^b, 5^c, or 7^d

  uint32_t target =
      static_cast<uint32_t>(std::round(sampling_rate * target_interval));

  uint32_t p2a = target == 1 ? 1 : 1 << (32 - __builtin_clz(target - 1));
  uint32_t p2b = target == 1 ? 1 : 1 << (31 - __builtin_clz(target - 1));

  printf("t: %d\n", target);

  printf("p2a: %d\n", p2a);
  printf("p2b: %d\n", p2b);

  return 0;
}

uint32_t closest_pow2(uint32_t x) {
  uint32_t p2a = x == 1 ? 1 : 1 << (32 - __builtin_clz(x - 1));
  uint32_t p2b = p2a << 1;

  printf("p1: %d\n", p2a);
  printf("p2: %d\n", p2b);

  return p2a;
}

void Transformer::window(WindowFunc func) {
  get_best_n(1.0, 44100);

  return;

  size_t s = buffer_.size();

  for (size_t i = 0; i < s; i++) {
    double d = buffer_.at(i);

    switch (func) {
      case WindowFunc::RECTANGULAR: {
        d = win_rectangular(d, i, s);
        break;
      }
      case WindowFunc::HANN: {
        d = win_hann(d, i, s);
        break;
      }
    }

    buffer_.at(i) = d;
  }
}
